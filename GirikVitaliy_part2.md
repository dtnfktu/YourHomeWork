[comment]: # (Вторая версия шпаргалки, по мотивам второго семинара по git)

# **Рукводоство по работе с Git**

## Базовые команды git

Имя пользователя нужно, чтобы привязывать коммиты к вашему имени. Это не то же самое, что имя пользователя учётной записи GitHub, с помощью которого выполняется вход в профиль на GitHub. Задать или изменить имя пользователя можно с помощью команды **git config**. Новое имя будет автоматически отображаться в последующих коммитах, отправленных на GitHub через командную строку. 

* **git config --global user.name "User Name"**

Кроме того, командой **git config** можно изменять адрес электронной почты, привязанный к вашим коммитам Git. Новый адрес электронной почты будет автоматически отображаться во всех дальнейших коммитах, поданных на GitHub через командную строку.

* **git config --global user.email "user@email.com"**

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром **init**. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.

* **git init**

Добавить отдельный файл в область подготовленных файлов можно параметром **add** с указанием имени файла. Просто замените somefile.js на актуальное имя.

* **git add somefile.js**

Кроме того, можно добавить все файлы и папки в эту область, предоставив _wildcard_ . вместо имени файла:

* **git add .**

Просмотреть статус нужного репозитория можно по ключевому слову **status**: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.

* **git status**

При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра **commit** с флагом _-m_. Само сообщение вводится непосредственно после флага, в кавычках.

* **git commit -m "I commited this file"**

Просматривать изменения, внесённые в репозиторий, можно с помощью параметра **log**. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг _-p_, вы можете подробно изучить изменения, внесённые в каждый файл.

* **git log -p**

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра **show**, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.

* **git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29**

Также можно использовать сокращённый хеш.

* **git show 1af17e**

Можно просматривать список изменений, внесённых в репозиторий, используя параметр **diff**. По умолчанию отображаются только изменения, не подготовленные для фиксации.

* **git diff**

Для просмотра подготовленных изменений необходимо добавить флаг _--staged_.

* **git diff --staged**

Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.

* **git diff somefile.js**

Удалять файлы из текущего рабочего дерева можно с помощью параметра **rm**. При этом файлы удаляются и из индекса.

* **git rm dirname/somefile.js**

Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.

* **git rm dirname/*.html**

Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром **checkout**. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр _git checkout_ изменит указатель _HEAD_, чтобы задать указанную ветку как текущую.

* **git checkout somefile.js**

Восстановить подготовленный файл рабочего дерева можно параметром _reset_. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.

* **git reset HEAD somefile.js**

Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.

* **git reset HEAD**

Внести изменения в последний коммит можно параметром **commit** с флагом _--amend_. Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.

* **git commit --amend -m "Dislike message for the previous commit"**

***С помощью amend прекрасно исправляются локальные коммиты, а исправления можно передать в общий репозиторий. Однако изменять коммиты, уже доступные другим пользователям, не следует. Помните, что изменённые коммиты являются совершенно новыми, а предыдущий коммит уже не будет доступен в текущей ветке. Последствия будут такими же, как при отмене изменений публичного снимка.***

Для слияния веток используем команду **git merge** с указанием имени  ветки, котрую будем сливать с той веткой, в которой в данный момент находимся
* **git merge имя_ветки**

**Просмотр истории коммитов**

После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда git log.


## Особенности работы с репозиториями
**Игнорирование файлов**

Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл .gitignore. с перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:
* $ cat .gitignore
* *.[oa]
* *~
Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» — объектные и архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т. д. и т. п. Хорошая практика заключается в настройке файла .gitignore до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.


## ***Особенности работы с репозиториями***

Git - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

С помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

Репозиторием называют хранилище вашего кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.

Так же ваши репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:

    GitHub (https://github.com/)

    Bitbucket (https://bitbucket.org/)

    GitLab (https://gitlab.com/)

## Перемещение между коммитами

Чтобы создать новую ветку, нужно использовать команду **git checkout** с указанием имени ветки. Таким образом вы создадите ответвление той ветки, в которой находитесь. История новой ветки начнется с момента ответвления.

Чтобы перейти в уже существующую ветку, используйте ту же команду **git checkout**, но **без добавления флага -b**. Команде нужно передать имя ветки, в которую вы хотите перейти.

Для перехода в предыдущую ветку (т. е. ту, из которой вы перешли в текущую) можно передать команде **git checkout** не имя ветки, а **просто дефис**.

Чтобы перейти к определенному коммиту, используйте ту же команду **git checkout**, но вместо имени ветки передайте ей **SHA** коммита.

Ветки по сути являются просто указателями трекерами отдельных коммитов в истории Git.

Один из способов найти SHA коммита — просмотреть лог Git. Делается это при помощи команды **git log**.

В первой строке каждого коммита после слова commit есть длинная строка букв и цифр. Вот она и называется SHA. Это уникальный идентификатор, генерируемый для каждого коммита.

## **Управление ветками**

Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.
Команда git branch делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток.
